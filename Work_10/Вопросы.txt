таблица виртальных методов
	таблица для вызова переопределенных методов
	для каждого базового класса своя таблица
	потомки методы потомков будут записаны с соответствующим сдвигом в таблице
	в классе хранится и обрабатывается невидимое поле - ссылка на соответствующую таблицу
позднее связывание
	ранее связывание - обычный(невиртуальный)/статический метод определяется по типу переменной в написанном коде на этапе компиляции (быстрее)
	позднее связывание - виртуальный/переопределенный метод определяется по типу конкртеного значения переменной на этапе выполнения
override и overload отличие
	перегрузка - разные параметры(количество, порядок, тип, модификаторы)
	overrride - переопределение ой же самой функции для потомков данного класса
зачем интерфейсы
	набор методов с заданной ассигнатурой, реализация которых должна быть в данном классе
	Позволяет декларировать, что какой-то набор классов (возможно никак друг с другом не связвнных) выполняет заданный набор операций
	иногда не имеет значение конкретный тип, а важно, что определены заданные функцции
	можно возвращать, объявлять, хранить по имени интерфейса, если не важна конекретная реализация
	Класс B дожен быть базовым для класса A если:
		- A должно быть сущностью класса B, например
			"можно считать площадь"->квадрат - не подходит: можно считать площадь - не сущность, а свойство
			квадрат->прямоугольник - не подходит: не каждый прямоугольник  - квадрат
		- A должен расширять класс B, то есть всё, что исопльзуется в B должно использоваться в A(иначе нужно наследовать от класса с общей частью), например
			прямоугольник->квадрат - не подходит: в прямоугольнике хранится две стороны, а в квадрате либо одна либо дублируется
	То, что не сущность - это свойства, надо выделять в интерфейс
про клонирвание и поверхностное копировнеи разница
	поверхнотсное клонирование - создает новый обхект, копирует нестатические поля
		если поле ссылочного типа, копируется ссылка на тот же объект
		если поле хранится по значению. копируется значение
	глубокое копирование - создает новый объект, копирует нестатические поля
		все поля создает новые (со старыми значениями)